# java-learning


###day 03
1. "" + 基本类型，执行字符串转换
2.  按位与“&” 、按位或“|”、逻辑与“&&”、逻辑或“||”
3. 截尾和舍入：float 和 double在转换为int时总是会被截尾，舍入要用Math.round()
4. 表达式中出现的最大数据类型决定了表达式结果的数据类型
5. 所有基本类型的大小是确定的
6. 布尔值不能相加，以及进行其他任何操作（包括不能转换成其他的基本数据类型）
7. Java中唯一用到逗号操作符的地方就是for循环的初始化和布进部分
8. foreach (a)任何一个返回数组的方法都可以使用foreach (b）foreach可以用于任何Iterable对象
9. 由goto想到：通过限制语言的能力，反而能使一项语言特性更加有用
10. 把一个int型当做字符打印需要先转成char,否则会输出一个整数
11. 斐波那契数列：每一个数都是前两个数的和。前5个数为：1、1、2、3、5
12. 吸血鬼数字是指位数为偶数的数字，可以由一对数字相乘而得到，而这对数字各包含乘积的一半位数的数字，其中从最初的数字中选取的数字可以任意排序。
   以两个0结尾的数字是不允许的，例如，下列数字都是“吸血鬼”数字：
   1260 = 21 * 60 　1827 = 21 * 87 　2187 = 27 * 81
   4位数的吸血鬼数有7个：
   1260, 1395, 1435, 1530, 1827, 2187, 6880

###day 04
1. 构造器没有返回值
2. 每个重载的方法都要有一个独一无二的参数类型列表
3. 涉及基本类型的重载：(a)如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。char型略有不同，如果找不到恰好接受char类型参数的方法，就会把char型直接提升为int型
    (b)如果传入的实际参数类型较大，就得通过类型转换来执行窄化转换，如果不这样做，编译器会报错。
4. 不能通过返回值区分重载方法
5. this 代表对“调用方法的那个对象”的引用
6. this(...) 表示调用不同参数类型的构造器，而且只能在构造器调用另一个构造器。
7. 当参数s的名称和数据成员s的名字相同时，会产生歧义，使用this.s 来表示数据成员就能解决这个问题
8. 对象可能不会被垃圾回收
9. 因为对象被清理前都会调用一次finalize()方法，所以可以重写finalize()来验证对象被清理的时候是否符合条件
10-a. 从栈和静态储存区出发，追踪所有的引用，找到和引用连接的所有存活的对象，直到整个网络结束。
10-b. 自适应的、分代的、停止-复制、标记-清扫式垃圾回收器
11. 无法阻止自动初始化的进行，他将在构造器被调用之前进行
12. 在类的内部，变量定义的顺序决定了初始化的顺序。所有变量的初始化会在任何方法调用之前（包括构造器）完成
13. 静态变量初始化和非静态变量初始化的值没什么区别，静态变量只会在首次用到类的时候初始化一次
14. 初始化的顺序是先静态对象，然后是"非静态"对象
15. 使用实例初始化，可以保证无论调用哪个构造器都执行某些变量的初始化,而且实例初始化也会在构造器调用之前执行
16. 对象数组创建后，如果没有给里面的元素赋值就使用的话，会得到运行时异常
17. 如果已有一个数组，可以把它当做可变参数列表来接受
18. 将0个参数传递给可变参数列表是可行的
19. 如果有必要，可变参数列表会自动执行包装转换
20. enum 可以用于switch语句中

###day 05
1. 作为一名类库设计员，你会尽可能把一切方法都设计成private，只向客户端程序员公开你希望他们使用的方法
2. 一个java源文件，可以说是一个编译单元，一个编译单元只可以有一个public类，如果有另外的类，另外的类仅仅包内可见
3. CLASSPATH包含一个或多个文件，用来查找.class文件的根目录。从根目录开始，解释器会寻找创建类用到的.class文件，在这过程中，寻找包的时候会把所有.号都替换成/或者\。例如foo.bar.baz会变成foo/bar/baz
4. CLASSPATH在使用jar文件的时候会有点不同，必须指定jar文件的名字  CLASSPATH = C:\color\red.jar
5. 在使用有冲突的名字的情况下，必须返回到指定类的全名  List ...   java.util.List...
6. 条件编译：用于调试，调试是对开发版开放的，对发布版关闭的。可以通过修改被导入的package来实现，具体来说就是将代码从开发版切换到发布版
7. 提供get/set方法访问和改变数据，是最优雅的方式，也是JavaBeans的基本原理
8. default 默认是包访问权限，如果这时候发生继承，那么子类也是没办法使用父类中default 成员的，只能使用protected 成员（如果父类和子类不在同一个包中的话）
9. 访问权限控制将权限划分在数据类型的内容。 意义：1.设定客户端程序员可以使用和不可以使用的边界。 2.接口和实现分离，类设计者可以随意改动非public的成员，而不会对客户端的使用造成影响
10. 类的复用包括组合 和 继承
11. 惰性初始化，在正要使用这些对象之前进行初始化
12. 每创建一个类，总是在继承，不是显式继承，就是隐式继承Object
13. 当继承发生后，派生类会自动得到基类所有的（public）域和方法
14. 即使一个类只有包访问权限，public main() 仍是可以访问的
15. 继承规则：将所有的数据成员设为private，将所有方法设为public
16. super.xxx() 将调用基类的 xxx() 版本
17. 当创建一个导出类对象的时候，该对象包含一个基类的子对象。这个子对象和新建的基类对象没有什么区别。只是一个在外部，一个在导出类的内部。
18. 构建是从基类向外扩散的，所有基类在导出类初始化之前就已经完成了初始化。
19. 如果没有默认的基类构造器，或者想要调用一个带参数的基类构造器，那么就需要使用super()来显式调用，并配以适当的参数列表。
20. 代理：组合会把成员对象的所有方法暴露给组合后的对象，代理可以解决这个问题
21. 基类的清理要和构建的顺序相反，保证基类存活到最后